# ASP.NET Core

# Build and test ASP.NET Core projects targeting .NET Core.
# Add steps that run tests, create a NuGet package, deploy, and more:
# https://docs.microsoft.com/azure/devops/pipelines/languages/dotnet-core

trigger:
- master

#pool:
# vmImage: ubuntu-latest

#variables:
#  buildConfiguration: 'Release'

#steps:
#- script: dotnet build --configuration $(buildConfiguration)
#  displayName: 'dotnet build $(buildConfiguration)'

# This example runs three stages, one after another. The middle stage runs two jobs in parallel. 

# stages:
# - stage: Build
#   jobs:
#   - job: BuildJob
#     steps:
#     - script: echo Building!
# - stage: Test
#   jobs:
#   - job: TestOnWindows
#     steps:
#     - script: echo Testing on Windows!
#   - job: TestOnLinux
#     steps:
#     - script: echo Testing on Linux!
# - stage: Deploy
#   jobs:
#   - job: Deploy
#     steps:
#     - script: echo Deploying the code!

# This example runs two stages in parallel. For brevity, the jobs and steps are omitted.
# stages:
#   - stage: BuildWin
#     displayName: Build for Windows
#     jobs:
#     - job: BuildJobWindows
#       steps:
#       - script: echo Building for Windows!
#   - stage: BuildMac
#     displayName: Build for Mac
#     jobs:
#       - job: BuildJobMac
#         steps:
#         - script: echo Building for Mac!
#    dependsOn: [] # by specifying an empty array, this stage doesn't depend on the stage before it

#Example jobs that build sequentially:
# jobs:
#   - job: Debug
#     steps:
#     - script: echo hello from the Debug build
#   - job: Release
#     dependsOn: Debug
#     steps:
#     - script: echo hello from the Release build

# Example jobs that build in parallel (no dependencies):
# jobs:
#   - job: Windows
#     pool:
#       vmImage: 'vs2017-win2016'
#     steps:
#     - script: echo hello from Windows
#   - job: macOS
#     pool:
#       vmImage: 'macOS-10.14'
#     steps:
#     - script: echo hello from macOS
#   - job: Linux
#     pool:
#       vmImage: 'ubuntu-16.04'
#     steps:
#     - script: echo hello from Linux  

# Example of fan-out:
# jobs:
#   - job: InitialJob
#     steps:
#     - script: echo hello from initial job
#   - job: SubsequentA
#     dependsOn: InitialJob
#     steps:
#     - script: echo hello from subsequent A
#   - job: SubsequentB
#     dependsOn: InitialJob
#     steps:
#     - script: echo hello from subsequent B

# Example of fan-in:
# jobs:
#   - job: InitialA
#     steps:
#     - script: echo hello from initial A
#   - job: InitialB
#     steps:
#     - script: echo hello from initial B
#   - job: Subsequent
#     dependsOn:
#     - InitialA
#     - InitialB
#     steps:
#     - script: echo hello from subsequent


#############CONDITIONS
# # Example to run a job based upon the status of running a previous job:
# jobs:
#   - job: A
#     steps:
#     - script: exit 1
  
#   - job: B
#     dependsOn: A
#     condition: failed()
#     steps:
#     - script: echo this will run when A fails
  
#   - job: C
#     dependsOn:
#     - A
#     - B
#     condition: succeeded('B')
#     steps:
#     - script: echo this will run when B runs and succeeds

# The matrix strategy enables a job to be dispatched multiple times, with different variable sets. 
# The maxParallel tag restricts the amount of parallelism. The following job will be dispatched three times
# with the values of Location and Browser set as specified. However, only two jobs will run at the same time.

# jobs:
#   - job: Test
#     strategy:
#       maxParallel: 2
#       matrix: 
#         US_IE:
#           Location: US
#           Browser: IE
#         US_Chrome:
#           Location: US
#           Browser: Chrome
#         Europe_Chrome:
#           Location: Europe
#           Browser: Chrome

# Here's an example of defining variables in a job and using them within tasks.
# https://docs.microsoft.com/en-us/azure/devops/pipelines/process/phases?tabs=yaml&view=azure-devops#job-variables

# variables:
#   mySimpleVar: simple var value
#   "my.dotted.var": dotted var value
#   "my var with spaces": var with spaces value

# steps:
# - script: echo Input macro = $(mySimpleVar). Env var = %MYSIMPLEVAR%
#   condition: eq(variables['agent.os'], 'Windows_NT')
# - script: echo Input macro = $(mySimpleVar). Env var = $MYSIMPLEVAR
#   condition: in(variables['agent.os'], 'Darwin', 'Linux')
# - bash: echo Input macro = $(my.dotted.var). Env var = $MY_DOTTED_VAR
# - powershell: Write-Host "Input macro = $(my var with spaces). Env var = $env:MY_VAR_WITH_SPACES"

#Run if a variable is null
variables:
  - name: testNull
    value: ''
  
jobs:
  - job: Runifavariableisnull
    steps:
    - script: echo testNull is blank
    condition: eq('${{ variables.testNull }}', '')